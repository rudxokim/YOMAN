# YOMAN: UnitService Architecture

> SampleRNN의 계층적 시간 스케일 개념을 LLM 기반 프로젝트 관리에 적용하여,
> 컨텍스트 한계를 극복하고 "컴퓨터 없이" 개발할 수 있는 시스템

---

## 1. 프로젝트 개요

### 1.1 한 줄 요약

**YOMAN** = LLM이 안전하게 기능을 파악할 수 있는 **UnitService Architecture**

### 1.2 핵심 문제

```
마이크로서비스 아키텍처조차도 사람한테 특별한거지
LLM에게는 너무 큰 context임.
```

- 전체 프로젝트: 20,000+ tokens → LLM 혼란
- 마이크로서비스: 5,000 tokens → 여전히 부담
- **유닛**: 200-500 tokens → LLM이 완벽히 이해

### 1.3 영감의 원천

| 출처 | 핵심 개념 | YOMAN 적용 |
|------|----------|-----------|
| **SampleRNN** (ICLR 2017) | 계층적 시간 스케일 | 유닛 → 모듈 → 전체 계층 |
| **마이크로서비스** | 단일 책임, 독립 배포 | Operation 개념 |
| **인지 심리학** | 7±2 항목 한계 | 작은 단위로 분할 |

---

## 2. SampleRNN에서 배운 것

### 2.1 SampleRNN 논문 요약

**SampleRNN: An Unconditional End-to-End Neural Audio Generation Model**
(Mehri, Kumar, Gulrajani 등, ICLR 2017)

```
┌─────────────────────────────────────────────────────────────┐
│  Tier 3 (최상위)                                            │
│  - 가장 느린 clock rate                                     │
│  - 추상적 패턴 (음소, 단어 수준)                             │
│  - Stateful RNN                                             │
├─────────────────────────────────────────────────────────────┤
│  Tier 2 (중간)                                              │
│  - 중간 clock rate                                          │
│  - Frame 단위 처리                                          │
│  - Stateful RNN                                             │
├─────────────────────────────────────────────────────────────┤
│  Tier 1 (최하위)                                            │
│  - 가장 빠른 clock rate                                     │
│  - Sample 단위 (16kHz = 초당 16,000 샘플)                   │
│  - Memory-less MLP                                          │
└─────────────────────────────────────────────────────────────┘
```

**핵심 통찰**:
- 서로 다른 시간 스케일에서 작동하는 모듈 조합
- 상위 tier가 하위 tier를 conditioning
- Truncated BPTT로 짧은 시퀀스에서도 긴 의존성 학습

### 2.2 YOMAN으로의 매핑

```
SampleRNN                         YOMAN (UnitService)
══════════════════════════════════════════════════════════════
Tier 3 (최상위)          →        Opus (전체 싱크)
- 느린 clock rate                 - 프로젝트 전체 조망
- 추상적 패턴                     - 아키텍처 결정
- Stateful RNN                    - docs/Memory MCP 관리

Tier 2 (중간)            →        Sonnet (모듈)
- 중간 clock rate                 - Operation 관리
- Frame 단위                      - 유닛 그룹 통합
- 상위↔하위 연결                  - 컴포넌트 단위 작업

Tier 1 (최하위)          →        Flash/GLM (유닛)
- 빠른 clock rate                 - 단일 함수/클래스
- Sample 단위                     - 빠른 코드 생성
- Memory-less MLP                 - 여러 개 병렬 실행
══════════════════════════════════════════════════════════════
```

---

## 3. UnitService Architecture

### 3.1 3계층 구조

```
┌─────────────────────────────────────────────────────────────┐
│                     ㅇ (Opus)                               │
│  - 전체 프로젝트 싱크                                        │
│  - docs 업데이트                                            │
│  - 아키텍처 결정                                             │
└───────────────────────┬─────────────────────────────────────┘
                        │ conditioning
┌───────────────────────▼─────────────────────────────────────┐
│                     ㅁ (Sonnet)                             │
│  - 모듈/컴포넌트 단위                                        │
│  - Operation 관리                                           │
│  - 유닛 그룹 통합                                            │
└───────────────────────┬─────────────────────────────────────┘
                        │ conditioning
┌───────────────────────▼─────────────────────────────────────┐
│              유닛 (Flash/GLM4.7/Gem3.0)                     │
│  - 단일 함수/클래스                                          │
│  - 빠른 병렬 생성                                            │
│  - 양자 검증                                                 │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 양자 검증 패턴

여러 모델로 같은 유닛을 생성하고, 테스트 통과한 최적 버전 선택

```
유닛 A 구현 요청
       │
       ▼
┌──────────────────────────────────┐
│  GLM4.7  │  Gemini Flash  │  Gem3.0  │
│    ↓     │       ↓        │    ↓     │
│ 유닛 A1  │    유닛 A2     │ 유닛 A3  │
└──────────────────────────────────┘
       │
       ▼
   유닛 테스트 (자동)
       │
       ▼
   ┌───────────────┐
   │ 최적 유닛 선택 │ → 상위 계층으로 통합
   └───────────────┘
```

**장점**:
- 단일 모델 의존성 제거
- 품질 보장 (테스트 통과한 것만 선택)
- 비용 효율 (작은 모델들로 병렬 처리)

### 3.3 컨텍스트 최적화

| 규모 | 컨텍스트 | LLM 이해도 | 비용 |
|------|---------|-----------|------|
| 전체 프로젝트 | 20,000 tokens | ❌ 혼란 | $$$$ |
| 마이크로서비스 | 5,000 tokens | △ 부담 | $$$ |
| **유닛** | **200-500 tokens** | ✅ 완벽 | **$** |

**절감률**: 96% (20,000 → 500 tokens)

---

## 4. skim-stone: 실제 구현 체계

### 4.1 물수제비 메타포

```
첫 던짐        튀김1         튀김2         튀김3         착지
   │            │             │             │            │
   ▼            ▼             ▼             ▼            ▼
  💡  ───~───► 📊  ───~───►  ✅  ───~───►  🤖  ───~───► ✓
 IDEA       RESEARCH        TODO       CODINGBOT       PR
(러프)      (구조화)      (실행가능)    (검증완료)
```

**왜 물수제비인가?**
- 한 번에 완성 ✗, 여러 단계 거쳐 정제 ✓
- 각 단계마다 정보가 더 명확해짐
- 튀김 = 버킷 간 이동 (포맷 변환)

### 4.2 5가지 핵심 원칙

#### 원칙 1: 여러 단계 거쳐 정제

```
IDEA: "AI 에이전트 만들기" (불명확)
  ↓
RESEARCH: Notion API 조사, 아키텍처 설계 (구조화)
  ↓
TODO: Prerequisites + 소작전 분할 (실행 가능)
  ↓
PR: 코드 구현 + 검증 완료 (검증됨)
```

#### 원칙 2: 버킷 = 포맷 변환기

| 버킷 | AI | 출력 포맷 |
|------|-----|----------|
| IDEA | Gemini 2.5 Flash | 간단한 마크다운 |
| RESEARCH | Claude 4.5 | JSON + Mermaid |
| TODO | Gemini/Claude | JSON + Prerequisites |

#### 원칙 3: 방향 없는 그래프

```
     IDEA ←→ RESEARCH
       ↑ ↘    ↗ ↓
       |    ✕   |
       ↓  ↗  ↘ ↑
     TODO ←→ _self
```

- 필요하면 되돌아갈 수 있음 (TODO → RESEARCH)
- 필요하면 쪼갤 수 있음 (RESEARCH → IDEA 2개)
- 필요하면 재처리할 수 있음 (X → _self)

#### 원칙 4: 재귀 루프 (_self)

```
IDEA v1: "AI 에이전트 만들기" (불명확)
  ↓ 코멘트: "구체적으로 해줘"
  ↓ next_bucket = _self
IDEA v2: "Notion DB 자동 정리 AI 에이전트" (명확)
  ↓ next_bucket = RESEARCH
RESEARCH v1: ...
```

#### 원칙 5: GAN 검증

```
TODO ──────► CODINGBOT (Generator) ──────► PR
                                           │
                                           ▼
                                      REVIEWER (Discriminator)
                                           │
                                           ▼
                                        REPORT
                                           │
                     ┌─────────────────────┼─────────────────────┐
                     ▼                     ▼                     ▼
              match_rate ≥80%       50-80%                 <50%
                  PASS              PARTIAL                FAIL
               (PR 머지)          (TODO 생성)           (IDEA 생성)
```

---

## 5. 멀티모달 인터페이스 비전

> **idea2.txt (2025-12-31 추가)**

### 5.1 인터페이스 철학

> 우리가 원자로 구성되어있는 것처럼, 서비스도 그렇게 설계하고 싶음.
> 우리가 보는 건 '컨셉적인 형태'인 것.

**핵심 인사이트**:
- 유저는 `유닛`이나 `코드`를 직접 볼 필요 없음
- 추상화된 "컨셉적 형태"로 서비스 인식
- 원자 → 분자 → 물질처럼, 유닛 → 모듈 → 프로젝트

### 5.2 소통 채널 아키텍처

**기존 문제**: 텔레그램 단일 채널 → 한계

**새로운 방향**: 슬랙 수준의 멀티채널 협업 도구

```
┌─────────────────────────────────────────────────────────────┐
│                    YOMAN 인터페이스 레이어                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │
│  │  채팅   │  │ 보이스  │  │ 멀티모달 │  │ 그래프  │       │
│  │ (Text)  │  │ (Voice) │  │ (Media) │  │(Diagram)│       │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘       │
│       │            │            │            │             │
│       └────────────┴────────────┴────────────┘             │
│                         │                                   │
│                         ▼                                   │
│              ┌─────────────────────┐                       │
│              │    YOMAN Core       │                       │
│              │  (AI Orchestrator)  │                       │
│              └─────────────────────┘                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

| 채널 | 용도 | 예시 |
|------|------|------|
| **채팅 (Text)** | 명령, 짧은 지시 | `/code 인증 추가`, `PR 머지해` |
| **보이스 (Voice)** | 업무 보고 (양방향) | AI가 음성으로 보고, 유저가 음성으로 지시 |
| **멀티모달 (Media)** | 이미지, 오디오 첨부 | 스크린샷, 오디오 메모 |
| **그래프 (Diagram)** | 복잡한 구조 시각화 | 마인드맵, 아키텍처 다이어그램 |

### 5.3 보이스 인터페이스

**양방향 음성 소통**:

```
┌─────────────┐                    ┌─────────────┐
│    유저     │◄──── TTS ─────────│   YOMAN     │
│   (사람)    │                    │    (AI)     │
│             │───── STT ─────────►│             │
└─────────────┘                    └─────────────┘
```

**시나리오**:
1. **AI → 유저 (TTS)**: "오늘 진행 상황입니다. PR 3개 머지됐고, 테스트 커버리지 85%입니다."
2. **유저 → AI (STT)**: "오케이, 나머지 PR 리뷰 진행해"

**왜 보이스인가?**
- 손이 자유로움 (이동 중, 운전 중)
- 텍스트보다 빠른 전달
- 감정/뉘앙스 전달 가능

### 5.4 현황 대시보드

**전체 프로젝트 조망**:

```
┌─────────────────────────────────────────────────────────────┐
│                    📊 프로젝트 현황 탭                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ AUTOCODER   │  │  NOTION-MCP │  │  YOMAN      │        │
│  │  ✅ 85%     │  │   🔄 진행중  │  │  💡 아이디어 │        │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘        │
│         │                │                │                │
│         ▼                ▼                ▼                │
│    [클릭하면         [클릭하면         [클릭하면           │
│     세부 파트]        세부 파트]        세부 파트]          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**하이어라키 Drill-down**:

```
프로젝트 레벨 (ㅇ)
    │
    ├── 모듈 A (ㅁ)
    │       ├── 유닛 A1
    │       ├── 유닛 A2
    │       └── 유닛 A3
    │
    └── 모듈 B (ㅁ)
            ├── 유닛 B1
            └── 유닛 B2
```

- 탭/대시보드에서 프로젝트 전체 한눈에
- 클릭하면 세부 파트로 drill-down
- 최하위 유닛까지 탐색 가능 (필요시)

### 5.5 인터페이스 vs 실제 구현 분리

```
┌─────────────────────────────────────────────────────────────┐
│  유저가 보는 것 (컨셉적 형태)                                 │
│  ────────────────────────────────────────                   │
│  "프로젝트 현황", "모듈 A", "진행률 85%"                      │
│  → 추상화된 대시보드, 음성 보고                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ (숨겨진 복잡성)
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  실제 구현 (zorba-the-robot)                                │
│  ────────────────────────────────────────                   │
│  src/, tests/, .github/, entities/                         │
│  → 유닛 코드, 테스트, CI/CD, Memory MCP                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 6. "컴퓨터 없애기" 비전

### 6.1 핵심 인사이트

> **사람은 src/도 안 봄. 코드 자체를 안 봄.**

- 사람이 보는 것 = `docs/` (정리된 텍스트)
- 로봇이 보는 것 = `-zorba-the-robot/` (코드, 설정, 캐시)

### 6.2 프로젝트 구조

```
프로젝트/
│
├── docs/                          # 사람 영역 (5%)
│   ├── README.md
│   ├── guides/
│   ├── research/
│   ├── study/
│   └── ops/
│
└── -zorba-the-robot/              # 로봇 영역 (95%)
    ├── src/
    │   ├── CODINGBOT/
    │   ├── REVIEWER/
    │   ├── Bucket-Trigger/
    │   └── Daily-Log-Generator/
    ├── tests/
    ├── .github/
    ├── entities/                  # Memory MCP
    ├── relations/
    └── sync-scripts/
```

### 6.3 작업 흐름

**기존** (컴퓨터 필수):
```
1. 터미널에서 명령 실행
2. 10분 동안 로그 출력 지켜봄
3. 에러 발생 시 즉시 대응
4. 다른 작업 못 함
```

**새로운** (폰만 사용):
```
📱 Telegram: /code "사용자 인증 추가"
   ↓
   [AI가 알아서 처리 - 15분]
   ↓
📱 Telegram: "✅ PR #123 생성 완료. match_rate: 85%"
   ↓
📱 Telegram: "머지해"
   ↓
   완료!
```

### 6.4 Memory MCP로 컨텍스트 최적화

**기존**:
```python
# Claude가 매번 코드 읽기
Read("/path/to/bucket_trigger.py")  # 294줄, ~5000 tokens
```

**새로운**:
```python
# Memory MCP 조회
memory.search_nodes("BucketTrigger")

# 즉시 반환 (2초, 200 tokens):
{
  "entityType": "Service",
  "observations": [
    "Python Flask HTTP 서버",
    "Notion DB 자동화",
    "6개 핸들러 지원"
  ]
}
```

**절약률**: 96% (5000 → 200 tokens)

---

## 7. 마이크로서비스 철학 적용

### 7.1 Operation 개념

**마이크로서비스 원칙 → 프로젝트 관리 적용**

| 원칙 | 적용 |
|------|------|
| 단일 책임 | 하나의 Operation = 하나의 명확한 목표 |
| 독립 배포 | 독립적 완료 가능 (다른 Operation 대기 불필요) |
| 느슨한 결합 | Operation 간 의존성 최소화 |
| 작은 팀 소유 | 1-2명이 이해/관리 가능한 범위 |
| 장애 격리 | 하나의 Operation 실패가 전체 프로젝트 중단 안 함 |

### 7.2 심리학적 근거

| 이론 | 내용 | 적용 |
|------|------|------|
| Miller's Law | 단기 기억 7±2개 항목 | 태스크 3개로 제한 |
| Dunbar's Number | 안정적 관계 150명 | 팀 5-9명 |
| Zeigarnik Effect | 미완성 작업 스트레스 | 작은 단위 완료 |
| Flow State | 명확한 목표 + 즉각 피드백 | Operation 단위 |

---

## 8. 기대 효과

### 8.1 정량적 지표

| 메트릭 | 기존 | YOMAN 적용 후 | 개선율 |
|--------|------|--------------|--------|
| 토큰 사용 | 20,000 | 500 | **96% 절감** |
| 작업 시작 시간 | 30분 | 5분 | **6배 단축** |
| 파일 읽기 필요 | 99% | 5% | **94% 감소** |
| 응답 시간 | 30초 | 2초 | **15배 단축** |
| 병렬 작업 | 1개 | 3개+ | **3배 증가** |
| 인지 부하 (태스크) | 9개 | 3개 | **66% 감소** |

### 8.2 비용 절감

| 항목 | 월 비용 (Before) | 월 비용 (After) | 절감 |
|------|-----------------|----------------|------|
| Claude API | $150 | $40 | $110 |
| 개발 시간 | 80시간 | 50시간 | 30시간 |

---

## 9. 현재 상태 및 로드맵

### 9.1 완료

- [x] 아이디어 정립 (`idea.txt`)
- [x] 인터페이스 비전 정립 (`idea2.txt`) ✨ NEW
- [x] 철학 문서화 (`docs/study/` 3개 폴더)
- [x] SampleRNN 논문 분석
- [x] skim-stone 기본 구현 (AUTOCODER v13)

### 9.2 진행 중

- [ ] zorba-the-robot 폴더 구조 설계
- [ ] Memory MCP 초기화
- [ ] 멀티채널 인터페이스 설계 ✨ NEW
- [ ] Telegram → 슬랙 수준 협업 도구 고도화 ✨ NEW

### 9.3 계획

- [ ] 유닛 서비스 프로토타입
- [ ] 양자 검증 파이프라인
- [ ] 3계층 모델 배치 자동화
- [ ] 보이스 인터페이스 (TTS/STT) ✨ NEW
- [ ] 현황 대시보드 UI ✨ NEW
- [ ] 그래프/다이어그램 시각화 ✨ NEW
- [ ] 완전한 "컴퓨터 없애기" 실현

---

## 10. 핵심 통찰

> **SampleRNN이 16kHz 오디오 시퀀스를 계층적으로 처리했듯이,
> YOMAN은 복잡한 소프트웨어 프로젝트를 계층적으로 관리하여
> LLM의 컨텍스트 한계를 극복한다.**

### SampleRNN → YOMAN 핵심 차용

| SampleRNN | YOMAN |
|-----------|-------|
| 다른 시간 해상도의 모듈 | 다른 능력의 LLM (Opus/Sonnet/Flash) |
| Frame-level → Sample-level | 프로젝트 → 모듈 → 유닛 |
| Memory-less MLP + Stateful RNN | 빠른 유닛 생성 + 상태 유지 통합 |
| Truncated BPTT | 작은 컨텍스트로 작업 |
| Conditioning vector | 상위 계층이 하위 계층 가이드 |

---

## 11. 참고 문서

### 프로젝트 내 문서

- `idea.txt` - 초기 아이디어 (UnitService Architecture)
- `idea2.txt` - 인터페이스 비전 (멀티모달 소통) ✨ NEW
- `sampleRNN.pdf` - 영감의 원천 논문
- `docs/study/251228-1815-autocoder-to-skim-stone/` - skim-stone 철학
- `docs/study/251231-1430-stone-skim-philosophy/` - 컴퓨터 없애기 비전
- `docs/study/microservices-for-project-management/` - 마이크로서비스 적용

### 외부 참고

- [SampleRNN Paper](https://arxiv.org/abs/1612.07837) - ICLR 2017
- [SampleRNN GitHub](https://github.com/soroushmehr/sampleRNN_ICLR2017)
- Martin Fowler - Microservices (2014)
- Miller's Law - The Magical Number Seven (1956)

---

## 부록: 용어 정리

| 용어 | 정의 |
|------|------|
| **YOMAN** | UnitService Architecture 프로젝트 이름 |
| **유닛** | LLM이 완벽히 이해할 수 있는 가장 작은 코드 단위 |
| **skim-stone** | 물수제비. YOMAN 철학의 실제 구현 시스템 |
| **버킷** | IDEA, RESEARCH, TODO 등 정보 포맷 변환기 |
| **Operation** | 마이크로서비스 개념을 프로젝트 관리에 적용한 작업 단위 |
| **zorba-the-robot** | AI가 관리하는 코드/설정 영역 |
| **GAN 검증** | Generator(CODINGBOT) + Discriminator(REVIEWER) |
| **양자 검증** | 여러 모델로 생성 후 테스트 통과한 최적 선택 |
| **Memory MCP** | 지식 그래프로 컨텍스트 99% 절약 |

---

*문서 생성일: 2025-12-31*
*분석 도구: Claude Opus 4.5, Sequential Thinking MCP, Memory MCP*
